# Теория разработки Qlik. Разбираем структуру каталогов, волшебные Include 

Это вторая часть Теории разработки Qlik из ...

## Список будущих статей - Теории разработки Qlik

- [x] Статья 1: [Инструменты и как я разрабатываю скрипты, VSCode (и дополнения к нему), Sublime](https://qlik.pw/teorija-razrabotki-qlik-instrumenty-i-kak-2_515/)
- [x] Статья 2: [Разбираем структуру каталогов, волшебные Include](https://qlik.pw/teorija-razrabotki-qlik-razbiraem-struktu_529/)
- [x] Статья 3: [Извлекаем скрипты из QVW и выбираем GIT](https://qlik.pw/teorija-razrabotki-qlik-izvlekaem-skript_535/)
- [ ] Статья 4: Пользовательская документация, автоматическое обновление её на сервере и копаем accesspoint (QV)
- [ ] Статья 5: Пользуемся GIT внутри VSCode и как это отражается на продакшн-сервере QlikView
- [ ] Статья 6: Используем функции из QVC (QlikView-Components), ускорение загрузки данных если есть Where ... 

Если вам показалось что-либо непонятным, неточным, если упущен момент дзен или просто появились вопросы, приглашаю:
* Чат-группа: [https://tele.click/QlikRU](https://tele.click/QlikRU) @QlikRU
* Информационный канал: [https://tele.click/qlikd](https://tele.click/qlikd) @QlikD
* Можно писать в личку: [https://tele.click/Chernov](https://tele.click/Chernov) @Chernov

## Что будет использовано из софта в этой статье

* Visual Studio Code
* QlikView November 2018

## Про структуру каталогов

Знаете, я шёл к этому долгих 3 года... почему мне об этом никто раньше не сказал?

Лично у меня на сервере и на рабочей машине путь до этой структуры единый: D:\QLIK\Dev, у вас может быть разный - не важно. Главное не размещайте тут каталог с опубликованными приложениями, лично мне это кажется не совсем правильным.

Каталог, который вы укажете в QlikView сервере будет именно этот. Собственно, представляю структуру с кратким описанием, а далее по тексту разберем всё подробно:

| Каталог          | Описание                                                                           |
| ---------------- | ---------------------------------------------------------------------------------- |
| 10_Scripts       | Каталог хранения всех *.qvs файлов                                                 |
| 20_Resources     | Каталог для хранения различных справочников (csv,txt,xls*), картинок и прочего     |
| 30_QvdGenerators | Каталог хранения QVD файлов и всех скриптов ETL-процесса                           |
| 40_DataModel     | Каталог для хранения моделей приложений                                            |
| 50_Application   | Каталог UI приложений, загрузка в них производится из 40_DataModel файлов в binary |
| 60_Temp          | Временный каталог для чего угодно                                                  |
| 90_Documentation | Каталог для хранения пользовательской документации в MarkDown формате              |

## Немного настройки VSCode

Сначала создаем нужные каталоги, затем делаем Open Folder и указываем наш корневой каталог, после - сохраняем workspace (я сохранил в корень диска D). В дальнейшем, мы открываем VSCode -> Open Workspace - наш файл, вуаля у нас загружается вся структура в виде дерева файлов в которой мы и работаем. 

![](https://gitlab.com/bintocher/qlik.pw-site/raw/master/Инструкции/images/mstsc_oImiuFMHJi.png)

![](https://gitlab.com/bintocher/qlik.pw-site/raw/master/Инструкции/images/mstsc_IdlIBqHhgx.png)

Но плюс, от использования Workspace не только в том что он загружает нашу структуру каталогов, а в том, что мы можем хранить дополнительные, или единые настройки для самого VSCode через файл - settings.json , который будет создан в каталоге .vscode, т.е. настройки в VSCode делятся на три типа - "По-умолчанию", "Пользовательские" и "Настройки рабочего окружения". Если найдете практическое применение этому - будет отлично, лично мне они пока не понадобились, но всё может скоро изменится.

Ах да, этот файл настроек вы можете выгружать в git, и затем использовать на любой другой машине где ведете разработку, собственно настройки VSCode будут везде одинаковые.

## Подробно про каталоги

### 10_Scripts

Тут вы храните все скрипты всех ваших приложений! В том числе и те которые называются tmp.qvw, del.qvw и т.д. - это упросит поиск по коду. Без подпапок.

Файлы *.qvs должны называться точно так же, как и файлы *.qvw

![logo](https://gitlab.com/bintocher/qlik.pw-site/raw/master/Инструкции/images/explorer_CdJIaUd55S.png)

### 20_Resources

Все вспомогательные файлы: картинки, Excel-файлы, текстовые, csv ...

Я тут храню так же файлы для коннекта к БД, т.е. файлы qvs, которые содержат в себе только одну строчку - CUSTOM CONNECT TO .... OLEDB CONNECT TO ....
```
А использую их в скриптах например так : $(Include=[$(ResLocation)\connect 1c.qvs]);
```

### 30_QvdGenerators

Как минимум в этом же каталоге я храню все QVD-файлы в папке QVD, а также разбиваю их по подпапкам.

Что касаемо самого каталога, в нём я стараюсь помещать файлы по их назначению. Основное назначение - это держать в этом месте все скрипты для Extract и Transform. Например, если это скрипт загрузки данных из источников, то файл будет называется extract_имяфайла. Если у меня преобразование данных, то файлы будут transform_имяфайла.

Помните про каталог 10_Scripts? - Так вот, если мы даем в префиксах имён файлов доп. значения, типа : extract_имя , transform_имя , model_имя , ui_имя - то затем, нам проще будет ориентироваться в общем каталоге со всеми скриптами.

### 40_DataModel

Здесь храним все файлы model, т.е. файлы с готовыми моделями данных приложений.

### 50_Application

Здесь храним все файлы ui, т.е. файлы с интерфейсом приложений. Загружаем в них данные через binary load [qs help](https://help.qlik.com/en-US/sense/September2018/Subsystems/Hub/Content/Sense_Hub/Scripting/ScriptRegularStatements/Binary.htm) , [qv help](https://help.qlik.com/en-US/qlikview/November2018/Subsystems/Client/Content/QV_QlikView/Scripting/ScriptRegularStatements/Binary.htm)

Почему ui отдельно от model?

Всё просто, модель данных может грузится от 5 секунд до 30-60 минут, было у меня такое в практике (правда давно, но было). А готовый файл с ui через binary - грузится 5-10 секунд (конечно, всё зависит от размера приложения с моделью). 

И вот представьте - вам нужно изменить форму таблицы, или срочно исправить какую-то формулу в графике, или же что-то еще. Т.е. сделать минимально быстрые изменения, которые нужны прямо сейчас. И тут мы отвечаем на свой вопрос - мы меняем UI, и обновляем приложение, потратив на всё это минуту - и пользователи уже довольные пользуются исправленным UI.

Или другой пример - права на приложения выдаются в момент публикации приложения на сервер, и вы используете named users, и указываете там пользователей из AD - И вот поступает запрос на то что нужно срочно выдать права сотруднику. Догадались? Права он получит уже через 10 секунд после того как вы нажмете кнопку обновления приложения.

### 60_Temp

Всё что угодно, в этом каталоге я так же храню временные QVD файлы, которые создаются во время выполнения скриптов и затем очищаются так же во время выполнения скриптов

### 90_Documentation

Каталог для хранения пользовательской документации, содержит в себе файлы .html и .md , так же есть каталог images/ в котором лежат все картинки.

Про создание пользовательской документации будет рассказано в отдельной статье.

## Волшебный Include. Файлы QVW содержат только 1 строку?

Да, именно так я и делаю, у меня абсолютно все файлы QVW - содержат в себе только 1 строчку кода!

```
$(Must_Include=C:\_any_file_include.qvs);
```

Практически на всех ОС Windows есть диск C. Я конечно знаю, как сделать чтобы его не было, но сейчас не об этом.

Must_Include или Include, по факту - не имеет значения, в первом случае будет вызвана ошибка выполнения, во втором - никакой ошибки не будет.

### Что же содержит в себе этот файлик? И почему он лежит именно там?
На самом деле всё просто, у нас может быть несколько сред разработки: это могут быть компьютеры разработчиков, это может быть DEV-сервер, это может быть TEST-сервер и это конечно же может быть PRODUCTION-сервер. И используя этот файл мы можем манипулировать переменными наших приложений. Смотрите сами, вот содержимое моего файла, которое я считаю универсальным и который подходит для любой среды окружения:
```
    // $(Include=C:\_any_file_include.qvs);
    SET ThousandSep=' ';
    SET DecimalSep=',';
    SET MoneyThousandSep=' ';
    SET MoneyDecimalSep=',';
    SET MoneyFormat='# ##0,00 ₽;-# ##0,00 ₽';
    SET TimeFormat='h:mm:ss';
    SET DateFormat='DD.MM.YYYY';
    SET TimestampFormat='DD.MM.YYYY h:mm:ss[.fff]';
    SET FirstWeekDay=0;
    SET BrokenWeeks=1;
    SET ReferenceDay=0;
    SET FirstMonthOfYear=1;
    SET CollationLocale='ru-RU';
    SET MonthNames='янв;фев;мар;апр;май;июн;июл;авг;сен;окт;ноя;дек';
    SET LongMonthNames='Январь;Февраль;Март;Апрель;Май;Июнь;Июль;Август;Сентябрь;Октябрь;Ноябрь;Декабрь';
    SET DayNames='Пн;Вт;Ср;Чт;Пт;Сб;Вс';
    SET LongDayNames='понедельник;вторник;среда;четверг;пятница;суббота;воскресенье';

    // Расположение каталога со скриптами
    SET vScriptFolder = 'D:\Qlik\Dev\10_Scripts';
    // Определяем название файла, который нужно загружать
    LET vInclude = '$(vScriptFolder)\' & mid(DocumentName(),1, len(DocumentName())-4) & '.qvs';
    // Заголовки файлов
    $(Must_Include='$(vScriptFolder)\_global_header.qvs');
    // Глобальные переменные
    $(Must_Include='$(vScriptFolder)\_global_vars.qvs');
    // Добавление фрэймворка 
    $(Must_Include='$(vScriptFolder)\_qvc.qvs');
    // Добавляем скрипт приложения
    $(Must_Include=$(vInclude));
    // Добавляем конец скрипта
    $(Must_Include='$(vScriptFolder)\_global_footer.qvs');
    // Очищаем переменные
    LET vInclude =;
    LET vScriptFolder =;
    // Завершаем скрипт
    EXIT SCRIPT;
```
### Содержимое _global_header.qvs
Раньше я хотел хранить в этом файле все нужные мне функции: SUB ...().

Первоначально у меня было две функции: SUB _TIMER и SUB _DELETETABLE, первая считала время от начала до окончания вызова функции, а вторая просто делала дроп таблицы (если она не существует, то ошибки не было). Функцию дропа таблиц я внёс в Qlik-Components, и называется она сейчас *Qvc.DropTable();*, а вместо функции таймера можно использовать *Qvc.Log();*

Сейчас, я пока не знаю под что еще можно использовать этот файл, но пусть пока будет на месте....
### Содержимое _global_vars.qvs
В этом файле я храню все глобальные переменные, ну или почти все.

Смотрите сами, например, мы делаем загрузку данных с какой-то даты, и потом с этой же даты мы делаем преобразование данных, вопрос - зачем на в двух скриптах использовать две переменных? Гораздо проще вытащить эту переменную в отдельный файл и уже из него манипулировать этим значением - неплохо?

Но не всё так классно пока у нас есть только глобальные переменные - мы ведь не хотим, например, на рабочем компе загружать 10 Gb из QVD - для тестов? Вот и я так думаю - поэтому я использую файл _local_vars.qvs - который переопределяет глобальные переменные и не выгружается в git.

Неполное содержимое моего _global_vars.qvs:
```
// Global vars
// Каталог хранения QVD
SET QVDLocation = 'D:\Qlik\Dev\30_QVDGenerators\QVD';

// Каталог хранения temp-QVD
SET QVDTempLocation = 'D:\Qlik\Dev\60_Temp\QVD';

// Каталог с ресурсами
SET RESLocation = 'D:\Qlik\Dev\20_Resources';

// Для полей
SET HIDEPREFIX = '%';

// дата время загрузки данных
LET vLastLoadTime = Now();

// Количество дней для загрузки данных в продажах (количество последних хх дней)
SET var.Sales.Days.To.Load = 10;

// Локальные переменные, для переопределения глобальных настроек

$(Include='$(vScriptFolder)\_local_vars.qvs');
```

### Содержимое _local_vars.qvs
```
// Переменная определяет текущее окружение,
// используется для разделения на DEV, PROD, TEST
// DEV - для разработки ; TEST - для тестирования ; PROD – продакшн-сервер
SET var.CurrentEnvironment = 'PROD';
```

Про переменную var.CurrentEnvironment - например, мы загружаем продажи на продакшн-сервере - все, а для тестов зачем нам все?
```qlik
IF var.CurrentEnvironment = 'DEV'
    LET vWhere = 'WHERE ДАТА > ' & Today(1)-10;
ELSEIF var.CurrentEnvironment = 'TEST'
    LET vWhere = 'WHERE ДАТА > ' & Today(1)-50;
ELSE
    vWhere = '';
END IF

SALES:
LOAD * FROM ....
$(vWhere) ;
```

Надеюсь тут всё понятно...
### Содержимое _qvc.qvs

В этом файле я держу Qlik-Components от Rob Wunderlich, про эти компоненты я уже кое что [писал в блоге](https://qlik.pw/qlikview-components-%D1%84%D1%80%D0%B5%D0%B9%D0%BC%D0%B2%D0%BE%D1%80%D0%BA-%D0%B4%D0%BB%D1%8F-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%BE%D0%B2_220/), в дальнейшем я опишу его полностью

### Содержимое _global_footer.qvs
```
// Очистка QVC-Components
CALL Qvc.Cleanup;

// Очистка не нужных переменных
LET QVDLocation = ;
LET var.Sales.ForceReload = ;
LET var.Sales.Days.To.Load = ;

LET vInclude =;
LET vScriptFolder =;

LET var.Sales.ToReload.LastDay = ;
LET var.Sales.ToReload.FirstDay = ;
LET var.CurrentEnvironment = ;
```

## Пример использования данной теории

Давайте представим такую историю: у нас есть БД, например, MySQL, и в ней у нас находятся данные от ПО - УКМ4 (это фронт-офис, проще говоря софт, который установлен на кассах в ритейл-магазине) - и нам нужно загрузить данные по продажам.

С чего начнём? Конечно - сначала изучаем БД, выясняем какие данные и откуда мы будем загружать, пишем select'ы. 
При загрузке данных кстати есть два пути : или мы делаем SELECT *, или мы пишем запросы которые отбирают только нужные данные.

Порядок действий:

* Сперва мы создаем в каталоге 20_ - файл qvs, в котором прописываем строку подключения к БД, называем его например - *connect_mysql.qvs*
* В каталоге 10_ создаем скрипт загрузки данных, например - extract_загрузка чеков.qvs (или load_, кому как удобно). И прописываем всё что нужно для загрузки и сохранения загруженных данных
* В каталоге 30_ создаем qvw-файл с именем extract_загрузка чеков.qvw, в котором только одна строчка: 
  ```
  $(Must_Include=C:\_any_file_include.qvs);
  ```
* В каталоге 10_ создаем model_чеки.qvs. Это скрипт который будет собирать все наши QVD-файлы в единую модель данных для конечного приложения
* В каталоге 40_ создаем qvw-файл с именем model_чеки.qvw, в котором одна строка 
  ```
  $(Must_Include=C:\_any_file_include.qvs);
  ```
* В каталоге 10_ создаем ui_чеки.qvs. Это скрипт который будет содержать какие то мелкие дополнения для нашего приложения, основная модель данных делается на прошлом шаге
* В каталоге 50_ создаем qvw-файл с именем ui_чеки.qvw, в котором 2 строки! 
  ```
  Binary [..\40_DataModel\model_чеки.qvw];
  $(Must_Include=C:\_any_file_include.qvs);
  ```


## Заключение

Я лишь отражаю свою точку зрения по разработке Qlik.

Данная статья на 100% подходит для использования в QlikView, что же касаемо Qlik Sense - так это то, что нужно лишь добавить нужные Lib:// каталоги в библиотеку и всё.

Всем Qlik